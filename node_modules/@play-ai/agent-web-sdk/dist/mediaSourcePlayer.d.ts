import { type MediaPlayer } from './mediaPlayer';
type AudioFormats = 'mp3' | 'wav' | 'mulaw';
export declare class MediaSourcePlayer implements MediaPlayer {
    private audioChunksQueue;
    private sourceBuffer;
    private audioElement;
    private audioContext;
    private onPlay;
    private onStop;
    private onEmpty;
    private shouldPlay;
    private audioFormat;
    private sampleRate;
    private mediaSource;
    readonly analyserNode: AnalyserNode;
    readonly mediaStreamDestNode: MediaStreamAudioDestinationNode;
    constructor(config: {
        format: AudioFormats;
        sampleRate?: number;
    });
    init({ onPlay, onStop, onEmpty }: {
        onPlay: () => void;
        onStop: () => void;
        onEmpty: () => void;
    }): Promise<void>;
    getIsPaused(): boolean;
    /**
     * Appends an audio chunk to the a queue which will be pushed to the source buffer.
     * The source buffer will process the queue and play the audio.
     * @param audioData
     */
    appendAudioChunk(audioData: Uint8Array): void;
    advance(): void;
    pause(): void;
    resume(): void;
    /**
     * Playback has stopped due to lack of data.
     * e.g. PLAY > PAUSE > RESUME > PLAYING
     */
    private elOnWaiting;
    /**
     * This event is fired when playback has started.
     * e.g. PLAY > PAUSE > RESUME > PLAYING
     */
    private elOnPlay;
    /**
     * Playback is ready to start after having been paused or delayed due to lack of data.
     * e.g. PAUSE > RESUME > PLAYING
     */
    private elOnPlaying;
    /**
     * The browser can play the media, but estimates that not enough data has been loaded to
     * play the media up to its end without having to stop for further buffering of content.
     * e.g.
     *  - CANPLAY > PLAY
     *  - CANPLAY > PLAY > PLAYING > WAITING >
     */
    private elOnCanPlay;
    /**
     * Playback has been paused.
     * e.g. PLAY > PAUSE
     */
    private elOnPause;
    /**
     * Play the audio element.
     */
    private systemPlay;
    clear(): void;
    /**
     * Processes the audio queue and appends the audio chunks to the source buffer.
     * - Can be called recursively to process the queue until it's empty.
     * - Can be called when the app-layer explicitly appends to the audio chunks queue.
     * @returns {undefined}
     */
    private processAudioQueue;
    private onSourceOpen;
    /**
     * Checks if the browser supports the given audio format and sample rate.
     * Cases in which the browser doesn't support the format:
     *  - MediaSource API is not supported (e.g. Safari, IE11, etc.)
     *  - Browser doesn't support the given sample rate (e.g. Safari)
     *  - Browser doesn't support the given format (e.g. Safari)
     *
     * @param format The audio format to check.
     * @param sampleRate The sample rate to check.
     * @returns True if the format and sample rate are supported, false otherwise.
     */
    static isFormatSupported(format: AudioFormats, sampleRate?: number): boolean;
    private getMimeType;
}
export {};
